<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mymories</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0a;
      --text: #f5f5f5;
      --muted: #b3b3b3;
      --glass-border: rgba(200,200,200,.35);
      --glass-bg: rgba(255,255,255,.04);
      --ring: rgba(255,255,255,.12);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 18px;
      --space: clamp(16px, 2.5vmin, 28px);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      height: 100%;
      overflow: hidden; /* Hide all overflow to prevent scrollbars */
    }

    body {
      font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(80vmax 80vmax at 50% -10%, rgba(255,255,255,.06), transparent 40%),
                  radial-gradient(40vmax 40vmax at 80% 10%, rgba(255,255,255,.05), transparent 60%),
                  var(--bg);
      color: var(--text);
      line-height: 1.65;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      position: relative;
    }

    /* Header */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      padding: var(--space);
      display: flex;
      justify-content: center;
      align-items: center;
      -webkit-backdrop-filter: blur(8px);
      backdrop-filter: blur(8px);
      background: rgba(10, 10, 10, 0.8);
      border-bottom: 1px solid var(--glass-border);
    }

    .back-btn {
      position: absolute;
      left: var(--space);
      -webkit-backdrop-filter: blur(8px);
      backdrop-filter: blur(8px);
      border: 1px solid var(--glass-border);
      background: var(--glass-bg);
      color: var(--text);
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      font-size: 20px;
      transition: all 0.18s ease;
      box-shadow: 0 1px 0 rgba(255,255,255,.06) inset, 0 10px 24px rgba(0,0,0,.25);
    }

    .back-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 14px 34px rgba(0,0,0,.38);
      border-color: rgba(220,220,220,.55);
      background: rgba(255,255,255,.06);
    }

    .menu-btn {
      position: absolute;
      right: 0;
      border: none;
      background: transparent;
      color: #888;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.18s ease;
    }

    .menu-btn:hover {
      color: #aaa;
    }

    .title {
      font-weight: 800;
      font-size: clamp(24px, 4vw, 36px);
      letter-spacing: 0.5px;
    }

    .subtitle {
      color: var(--muted);
      font-size: clamp(12px, 1.5vw, 14px);
      font-weight: 400;
    }

    /* Timeline Slider */
    .timeline-slider {
      position: fixed;
      bottom: 40px;
      left: 10%;
      right: 10%;
      z-index: 1000;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .timeline-slider-track {
      flex: 1;
      height: 4px;
      background: linear-gradient(90deg, 
        rgba(255,255,255,0.1), 
        rgba(255,255,255,0.3), 
        rgba(255,255,255,0.1)
      );
      border-radius: 2px;
      position: relative;
      margin: 0 20px;
      display: flex;
      align-items: center;
    }

    .timeline-memory-bar {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 8px;
      height: 20px;
      background: rgba(255,255,255,0.3);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 1px solid rgba(255,255,255,0.2);
    }

    .timeline-memory-bar:hover {
      background: rgba(255,255,255,0.5);
      height: 24px;
      border-color: rgba(255,255,255,0.4);
    }

    .timeline-memory-bar.active {
      background: rgba(255,255,255,0.8);
      height: 28px;
      border-color: rgba(255,255,255,0.6);
      box-shadow: 0 0 10px rgba(255,255,255,0.3);
    }

    .timeline-slider-thumb {
      position: absolute;
      top: 50%;
      left: 0%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      background: var(--glass-bg);
      border: 2px solid var(--glass-border);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .timeline-slider-thumb:hover {
      transform: translate(-50%, -50%) scale(1.2);
      border-color: rgba(255,255,255,0.6);
    }

    .timeline-year {
      -webkit-backdrop-filter: blur(8px);
      backdrop-filter: blur(8px);
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      box-shadow: var(--shadow);
      text-align: center;
      min-width: 60px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .timeline-year:hover {
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.4);
    }

    .timeline-year.active {
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.6);
      color: var(--text);
    }

    /* Timeline Container */
    .timeline-container {
      position: absolute;
      top: 50%;
      left: 0;
      width: 100%;
      height: 400px; /* Increased height to accommodate blur effects */
      transform: translateY(-50%);
      overflow: visible; /* Allow blur effects to show */
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none; /* Prevent text selection during swipe */
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    /* Grid Container */
    .grid-container {
      position: absolute;
      top: 50%;
      left: 0;
      width: 100%;
      height: 300px;
      transform: translateY(-50%);
      overflow: hidden;
      display: none;
      padding: 20px;
      box-sizing: border-box;
    }

    .grid-container.show {
      display: block;
    }

    .grid-bubbles {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 20px;
      max-width: 800px;
      margin: 0 auto;
      justify-items: center;
    }

    .grid-bubble {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      overflow: hidden;
      border: 2px solid transparent;
      aspect-ratio: 1;
    }

    .grid-bubble:hover {
      transform: scale(1.1);
      border-color: var(--glass-border);
      box-shadow: 0 0 20px rgba(255,255,255,0.2);
    }

    .timeline-track {
      position: relative;
      width: 80%;
      height: 4px;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255,255,255,0.2), 
        rgba(255,255,255,0.4), 
        rgba(255,255,255,0.2), 
        transparent
      );
      border-radius: 2px;
      margin: 0 auto;
    }

    .timeline-track::before {
      content: '';
      position: absolute;
      top: -2px;
      left: 0;
      right: 0;
      height: 8px;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255,255,255,0.1), 
        rgba(255,255,255,0.05), 
        rgba(255,255,255,0.1), 
        transparent
      );
      border-radius: 4px;
      filter: blur(1px);
    }

    .bubble {
      position: absolute;
      border-radius: 50%;
      cursor: pointer;
      transition: opacity 0.3s ease, transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      will-change: transform, left;
      overflow: hidden;
      border: 2px solid transparent;
      aspect-ratio: 1;
      transform-origin: center;
    }

    .bubble.active {
      transform: scale(2.5) translateY(-50%);
      border-color: rgba(255,255,255,0.35);
      box-shadow: 0 0 80px rgba(0, 100, 200, 0.6), 0 30px 60px rgba(0,0,0,0.5);
      z-index: 10;
      left: 50% !important;
      margin-left: -125px; /* Half of 250px to center perfectly */
      width: 250px !important;
      height: 250px !important;
    }

    .bubble.inactive {
      transform: scale(0.5) translateY(-50%);
      opacity: 0.7;
      width: 150px !important;
      height: 150px !important;
    }

    .bubble.hidden {
      opacity: 0;
      pointer-events: none;
      transition: none !important;
    }

    .bubble:hover:not(.hidden) {
      transform: scale(1.1) translateY(-50%);
      border-color: var(--glass-border);
      box-shadow: 0 0 30px rgba(255,255,255,0.2);
    }

    .bubble.inactive:hover {
      transform: scale(0.6) translateY(-50%);
    }

    .bubble.expanded {
      transform: scale(1.2);
      z-index: 100;
    }

    .bubble-content {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(0, 100, 200, 0.3));
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      /* Ensure perfect circle */
      aspect-ratio: 1;
    }

    .bubble-photo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 50%;
      /* Ensure perfect circle */
      aspect-ratio: 1;
    }

    .bubble-title {
      position: absolute;
      bottom: -30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.3s ease;
      background: rgba(0,0,0,0.8);
      padding: 4px 8px;
      border-radius: 12px;
      -webkit-backdrop-filter: blur(8px);
      backdrop-filter: blur(8px);
    }

    .bubble:hover .bubble-title {
      opacity: 1;
    }

    /* Connection Lines */
    .connection {
      position: absolute;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
      transform-origin: left center;
      opacity: 0.4;
      transition: opacity 0.3s ease;
      z-index: 1;
    }

    .connection-blur-tail {
      position: absolute;
      height: 8px;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255,255,255,0.1), 
        rgba(255,255,255,0.05), 
        transparent
      );
      transform-origin: left center;
      opacity: 0.2;
      transition: opacity 0.3s ease;
      z-index: 0;
      filter: blur(2px);
    }

    .bubble:hover ~ .connection,
    .bubble.expanded ~ .connection {
      opacity: 0.8;
    }

    .bubble:hover ~ .connection-blur-tail,
    .bubble.expanded ~ .connection-blur-tail {
      opacity: 0.4;
    }

    /* Bubble Detail Modal */
    .bubble-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .bubble-modal.show {
      opacity: 1;
      visibility: visible;
    }

    .modal-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      -webkit-backdrop-filter: blur(8px);
      backdrop-filter: blur(8px);
    }

    .modal-content {
      position: relative;
      max-width: 90vw;
      max-height: 90vh;
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      -webkit-backdrop-filter: blur(8px);
      backdrop-filter: blur(8px);
      box-shadow: var(--shadow);
      overflow: hidden;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .bubble-modal.show .modal-content {
      transform: scale(1);
    }

    .modal-photo {
      width: 100%;
      max-height: 60vh;
      object-fit: cover;
    }

    .modal-info {
      padding: var(--space);
    }

    .modal-title {
      font-size: clamp(18px, 2.5vw, 24px);
      font-weight: 800;
      margin-bottom: 8px;
      color: var(--text);
    }

    .modal-description {
      color: var(--muted);
      font-size: clamp(14px, 1.8vw, 16px);
      line-height: 1.6;
    }

    .modal-date {
      color: var(--muted);
      font-size: 12px;
      margin-top: 12px;
      opacity: 0.7;
    }

    .close-btn {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 32px;
      height: 32px;
      border: none;
      background: rgba(255,255,255,0.1);
      color: var(--text);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all 0.2s ease;
    }

    .close-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: scale(1.1);
    }

    /* Loading Animation */
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 3000;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid rgba(255,255,255,0.1);
      border-top: 3px solid var(--text);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .header {
        padding: 12px;
      }
      
      .bubble {
        min-width: 60px;
        min-height: 60px;
      }
      
      .modal-content {
        max-width: 95vw;
        margin: 20px;
      }
    }

    /* Accessibility */
    @media (prefers-reduced-motion: reduce) {
      .bubble, .connection, .modal-content {
        transition: none;
      }
      
      .loading-spinner {
        animation: none;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <a href="index.html" class="back-btn" aria-label="Voltar para p√°gina inicial">
      ‚Üê
    </a>
    <h1 class="title">Mymories</h1>
    <button class="menu-btn" id="menuBtn" aria-label="Toggle view">
      ‚ãØ
    </button>
  </header>

  <!-- Loading -->
  <div class="loading" id="loading">
    <div class="loading-spinner"></div>
  </div>

  <!-- Timeline Container -->
  <div class="timeline-container" id="timelineContainer">
    <div class="timeline-track" id="timelineTrack"></div>
    <!-- Bubbles will be generated dynamically -->
  </div>

  <!-- Grid Container -->
  <div class="grid-container" id="gridContainer">
    <div class="grid-bubbles" id="gridBubbles">
      <!-- Grid bubbles will be generated dynamically -->
    </div>
  </div>

  <!-- Timeline Slider -->
  <div class="timeline-slider" id="timelineSlider">
    <div class="timeline-year" id="firstYear">2013</div>
    <div class="timeline-slider-track" id="sliderTrack">
      <div class="timeline-slider-thumb" id="sliderThumb"></div>
      <!-- Memory bars will be generated dynamically -->
    </div>
    <div class="timeline-year" id="lastYear">2025</div>
  </div>

  <!-- Bubble Detail Modal -->
  <div class="bubble-modal" id="bubbleModal">
    <div class="modal-backdrop" id="modalBackdrop"></div>
    <div class="modal-content">
      <button class="close-btn" id="closeBtn">√ó</button>
      <img class="modal-photo" id="modalPhoto" alt="Memory photo">
      <div class="modal-info">
        <h2 class="modal-title" id="modalTitle"></h2>
        <p class="modal-description" id="modalDescription"></p>
        <p class="modal-date" id="modalDate"></p>
      </div>
    </div>
  </div>

  <script>
    class MymoryTimeline {
      constructor() {
        this.bubbles = [];
        this.currentIndex = 0;
        this.timelineContainer = document.getElementById('timelineContainer');
        this.timelineTrack = document.getElementById('timelineTrack');
        this.gridContainer = document.getElementById('gridContainer');
        this.gridBubbles = document.getElementById('gridBubbles');
        this.sliderThumb = document.getElementById('sliderThumb');
        this.firstYear = document.getElementById('firstYear');
        this.lastYear = document.getElementById('lastYear');
        this.modal = document.getElementById('bubbleModal');
        this.loading = document.getElementById('loading');
        this.menuBtn = document.getElementById('menuBtn');
        
        this.isDragging = false;
        this.startX = 0;
        this.currentTranslate = 0;
        this.isGridView = false;
        
        // Swipe detection properties
        this.swipeStartX = 0;
        this.swipeStartY = 0;
        this.swipeThreshold = 50; // Minimum distance for swipe
        this.isSwipeActive = false;
        this.swipeDirection = null;
        
        this.init();
      }

      async init() {
        try {
          await this.loadBubbles();
          this.createTimelineBubbles();
          this.createGridBubbles();
          this.setupSlider();
          this.addEventListeners();
          this.setActiveBubble(0);
          
          this.loading.style.display = 'none';
        } catch (error) {
          console.error('Error initializing Mymory Timeline:', error);
          this.loading.innerHTML = '<p>Erro ao carregar mem√≥rias</p>';
        }
      }

      async loadBubbles() {
        this.bubbles = [];
        
        try {
          const response = await fetch('bubbles.json');
          if (response.ok) {
            this.bubbles = await response.json();
            console.log(`‚úÖ Loaded ${this.bubbles.length} bubbles from bubbles.json`);
            return;
          }
        } catch (error) {
          console.log('üìÅ bubbles.json not accessible (CORS issue). Using embedded data...');
        }

        try {
          this.bubbles = await this.loadEmbeddedBubbles();
          console.log(`‚úÖ Loaded ${this.bubbles.length} bubbles from embedded data`);
        } catch (error) {
          console.error('‚ùå Error loading bubbles:', error);
          this.loading.innerHTML = `
            <div style="text-align: center; padding: 20px;">
              <h3>üöÄ Mymory Local Server Required</h3>
              <p>To avoid CORS issues, please use the local server:</p>
              <br>
              <p><strong>Windows:</strong> Double-click <code>start_server.bat</code></p>
              <p><strong>Or run:</strong> <code>python start_server.py</code></p>
              <br>
              <p>Then open: <code>http://localhost:8000/mymory.html</code></p>
            </div>
          `;
          return;
        }
      }

      async loadEmbeddedBubbles() {
        throw new Error('No embedded data available. Please use local server or ensure bubbles.json is accessible.');
      }

      createTimelineBubbles() {
        this.timelineContainer.innerHTML = '';
        this.timelineContainer.appendChild(this.timelineTrack);
        
        this.bubbles.forEach((bubbleData, index) => {
          const bubble = document.createElement('div');
          bubble.className = 'bubble';
          bubble.id = bubbleData.id;
          bubble.style.width = '250px';
          bubble.style.height = '250px';
          
          // Position bubbles horizontally along the timeline
          const timelineWidth = this.timelineContainer.offsetWidth * 0.8;
          const bubbleSpacing = timelineWidth / (this.bubbles.length - 1);
          const leftPosition = (index * bubbleSpacing) - 125; // Center the bubble (half of 250px)
          
          bubble.style.left = `${leftPosition}px`;
          bubble.style.top = '50%';
          bubble.style.transform = 'translateY(-50%)';
          
          const content = document.createElement('div');
          content.className = 'bubble-content';
          
          if (bubbleData.hasPhoto && bubbleData.photo) {
            const img = document.createElement('img');
            img.className = 'bubble-photo';
            img.src = bubbleData.photo;
            img.alt = bubbleData.title;
            content.appendChild(img);
          }
          
          const title = document.createElement('div');
          title.className = 'bubble-title';
          title.textContent = bubbleData.title;
          
          bubble.appendChild(content);
          bubble.appendChild(title);
          this.timelineContainer.appendChild(bubble);
          
          bubble.bubbleData = bubbleData;
          bubble.bubbleIndex = index;
        });
      }

      createGridBubbles() {
        this.gridBubbles.innerHTML = '';
        
        this.bubbles.forEach((bubbleData, index) => {
          const gridBubble = document.createElement('div');
          gridBubble.className = 'grid-bubble';
          gridBubble.id = `grid-${bubbleData.id}`;
          
          const content = document.createElement('div');
          content.className = 'bubble-content';
          
          if (bubbleData.hasPhoto && bubbleData.photo) {
            const img = document.createElement('img');
            img.className = 'bubble-photo';
            img.src = bubbleData.photo;
            img.alt = bubbleData.title;
            content.appendChild(img);
          }
          
          gridBubble.appendChild(content);
          this.gridBubbles.appendChild(gridBubble);
          
          gridBubble.bubbleData = bubbleData;
          gridBubble.bubbleIndex = index;
        });
      }

      setupSlider() {
        if (this.bubbles.length > 0) {
          const firstYear = new Date(this.bubbles[0].rawDate).getFullYear();
          const lastYear = new Date(this.bubbles[this.bubbles.length - 1].rawDate).getFullYear();
          
          this.firstYear.textContent = firstYear;
          this.lastYear.textContent = lastYear;
          
          this.createMemoryBars();
        }
      }

      createMemoryBars() {
        const sliderTrack = document.getElementById('sliderTrack');
        
        // Clear existing memory bars (keep the thumb)
        const existingBars = sliderTrack.querySelectorAll('.timeline-memory-bar');
        existingBars.forEach(bar => bar.remove());
        
        this.bubbles.forEach((bubbleData, index) => {
          const memoryBar = document.createElement('div');
          memoryBar.className = 'timeline-memory-bar';
          memoryBar.bubbleIndex = index;
          
          // Position the bar along the slider track (center the 8px bar)
          const trackWidth = sliderTrack.offsetWidth;
          const barPosition = (index / (this.bubbles.length - 1)) * trackWidth - 4; // Center 8px bar
          memoryBar.style.left = `${barPosition}px`;
          
          sliderTrack.appendChild(memoryBar);
        });
      }

      setActiveBubble(index) {
        this.currentIndex = index;
        
        // Update bubble states and positioning - show only 3 bubbles at a time
        document.querySelectorAll('.bubble').forEach((bubble, i) => {
          bubble.classList.remove('active', 'inactive', 'hidden');
          
          if (i === index) {
            // Active bubble in center
            bubble.classList.add('active');
            bubble.style.left = '50%';
            bubble.style.marginLeft = '-125px';
            bubble.style.width = '';
            bubble.style.height = '';
          } else if (i === index - 1) {
            // Previous bubble on the left
            bubble.classList.add('inactive');
            bubble.style.left = '25%';
            bubble.style.marginLeft = '-75px'; // Smaller base size for inactive
            // Remove inline size overrides to let CSS handle it
            bubble.style.width = '';
            bubble.style.height = '';
          } else if (i === index + 1) {
            // Next bubble on the right
            bubble.classList.add('inactive');
            bubble.style.left = '75%';
            bubble.style.marginLeft = '-75px'; // Smaller base size for inactive
            // Remove inline size overrides to let CSS handle it
            bubble.style.width = '';
            bubble.style.height = '';
          } else {
            // Hide bubble immediately without transition
            bubble.style.transition = 'none';
            bubble.classList.add('hidden');
            
            // Clear styles after the hidden state is applied
            requestAnimationFrame(() => {
              bubble.style.left = '';
              bubble.style.marginLeft = '';
              bubble.style.width = '';
              bubble.style.height = '';
              bubble.style.transform = '';
            });
          }
        });
        
        // Update slider thumb position
        const sliderTrack = this.sliderThumb.parentElement;
        const trackWidth = sliderTrack.offsetWidth;
        const thumbPosition = (index / (this.bubbles.length - 1)) * trackWidth;
        this.sliderThumb.style.left = `${thumbPosition}px`;
        
        // Update memory bars
        document.querySelectorAll('.timeline-memory-bar').forEach((bar, i) => {
          bar.classList.remove('active');
          if (i === index) {
            bar.classList.add('active');
          }
        });
        
        // Add parallax effect to visible bubbles
        this.updateParallaxEffect();
      }

      updateParallaxEffect() {
        document.querySelectorAll('.bubble').forEach((bubble, index) => {
          // Only apply parallax to visible bubbles (active, previous, next)
          if (index === this.currentIndex - 1) {
            // Previous bubble - slight parallax to the left
            bubble.style.transform = 'translateY(-50%) translateX(-10px)';
          } else if (index === this.currentIndex + 1) {
            // Next bubble - slight parallax to the right
            bubble.style.transform = 'translateY(-50%) translateX(10px)';
          } else if (index === this.currentIndex) {
            // Active bubble - no parallax
            bubble.style.transform = 'translateY(-50%)';
          } else {
            // Hidden bubbles - clear transform to prevent any visual artifacts
            bubble.style.transform = '';
          }
        });
      }

      addEventListeners() {
        // Bubble click handlers
        document.querySelectorAll('.bubble').forEach(bubble => {
          bubble.addEventListener('click', (e) => {
            e.stopPropagation();
            this.setActiveBubble(bubble.bubbleIndex);
            this.showBubbleDetail(bubble.bubbleData);
          });
        });

        // Memory bar click handlers
        document.addEventListener('click', (e) => {
          if (e.target.classList.contains('timeline-memory-bar')) {
            this.setActiveBubble(e.target.bubbleIndex);
          }
        });

        // Slider drag functionality
        this.sliderThumb.addEventListener('mousedown', (e) => {
          this.isDragging = true;
          this.startX = e.clientX;
          document.addEventListener('mousemove', this.handleSliderDrag.bind(this));
          document.addEventListener('mouseup', this.handleSliderRelease.bind(this));
        });

        // Touch events for mobile
        this.sliderThumb.addEventListener('touchstart', (e) => {
          this.isDragging = true;
          this.startX = e.touches[0].clientX;
          document.addEventListener('touchmove', this.handleSliderDrag.bind(this));
          document.addEventListener('touchend', this.handleSliderRelease.bind(this));
        });

        // Timeline container swipe and wheel
        this.timelineContainer.addEventListener('wheel', (e) => {
          e.preventDefault();
          if (e.deltaY > 0 && this.currentIndex < this.bubbles.length - 1) {
            this.setActiveBubble(this.currentIndex + 1);
          } else if (e.deltaY < 0 && this.currentIndex > 0) {
            this.setActiveBubble(this.currentIndex - 1);
          }
        });

        // Touch events for swipe detection
        this.timelineContainer.addEventListener('touchstart', (e) => {
          this.swipeStartX = e.touches[0].clientX;
          this.swipeStartY = e.touches[0].clientY;
          this.isSwipeActive = true;
        });

        this.timelineContainer.addEventListener('touchmove', (e) => {
          if (!this.isSwipeActive) return;
          
          const currentX = e.touches[0].clientX;
          const currentY = e.touches[0].clientY;
          const deltaX = currentX - this.swipeStartX;
          const deltaY = currentY - this.swipeStartY;
          
          // Check if horizontal swipe is more significant than vertical
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
            e.preventDefault();
            this.swipeDirection = deltaX > 0 ? 'right' : 'left';
            
            // Add visual feedback during swipe
            this.timelineContainer.style.cursor = 'grabbing';
            this.timelineContainer.style.opacity = '0.8';
          }
        });

        this.timelineContainer.addEventListener('touchend', (e) => {
          if (!this.isSwipeActive) return;
          
          const currentX = e.changedTouches[0].clientX;
          const deltaX = currentX - this.swipeStartX;
          
          if (Math.abs(deltaX) > this.swipeThreshold) {
            if (this.swipeDirection === 'left' && this.currentIndex < this.bubbles.length - 1) {
              this.setActiveBubble(this.currentIndex + 1);
            } else if (this.swipeDirection === 'right' && this.currentIndex > 0) {
              this.setActiveBubble(this.currentIndex - 1);
            }
          }
          
          // Reset visual feedback
          this.timelineContainer.style.cursor = '';
          this.timelineContainer.style.opacity = '';
          
          this.isSwipeActive = false;
          this.swipeDirection = null;
        });

        // Mouse events for desktop swipe
        this.timelineContainer.addEventListener('mousedown', (e) => {
          this.swipeStartX = e.clientX;
          this.swipeStartY = e.clientY;
          this.isSwipeActive = true;
        });

        this.timelineContainer.addEventListener('mousemove', (e) => {
          if (!this.isSwipeActive) return;
          
          const deltaX = e.clientX - this.swipeStartX;
          const deltaY = e.clientY - this.swipeStartY;
          
          // Check if horizontal movement is more significant than vertical
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
            this.swipeDirection = deltaX > 0 ? 'right' : 'left';
            
            // Add visual feedback during swipe
            this.timelineContainer.style.cursor = 'grabbing';
            this.timelineContainer.style.opacity = '0.8';
          }
        });

        this.timelineContainer.addEventListener('mouseup', (e) => {
          if (!this.isSwipeActive) return;
          
          const deltaX = e.clientX - this.swipeStartX;
          
          if (Math.abs(deltaX) > this.swipeThreshold) {
            if (this.swipeDirection === 'left' && this.currentIndex < this.bubbles.length - 1) {
              this.setActiveBubble(this.currentIndex + 1);
            } else if (this.swipeDirection === 'right' && this.currentIndex > 0) {
              this.setActiveBubble(this.currentIndex - 1);
            }
          }
          
          // Reset visual feedback
          this.timelineContainer.style.cursor = '';
          this.timelineContainer.style.opacity = '';
          
          this.isSwipeActive = false;
          this.swipeDirection = null;
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowLeft' && this.currentIndex > 0) {
            this.setActiveBubble(this.currentIndex - 1);
          } else if (e.key === 'ArrowRight' && this.currentIndex < this.bubbles.length - 1) {
            this.setActiveBubble(this.currentIndex + 1);
          }
        });

        // Modal close handlers
        document.getElementById('closeBtn').addEventListener('click', () => {
          this.hideBubbleDetail();
        });

        document.getElementById('modalBackdrop').addEventListener('click', () => {
          this.hideBubbleDetail();
        });

        // ESC key handler
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            this.hideBubbleDetail();
          }
        });

        // Menu button handler
        this.menuBtn.addEventListener('click', () => {
          this.toggleView();
        });

        // Grid bubble click handlers
        document.querySelectorAll('.grid-bubble').forEach(bubble => {
          bubble.addEventListener('click', (e) => {
            e.stopPropagation();
            this.setActiveBubble(bubble.bubbleIndex);
            this.showBubbleDetail(bubble.bubbleData);
            this.toggleView(); // Return to timeline view
          });
        });
      }

      handleSliderDrag(e) {
        if (!this.isDragging) return;
        
        e.preventDefault();
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const sliderTrack = this.sliderThumb.parentElement;
        const trackRect = sliderTrack.getBoundingClientRect();
        const trackWidth = trackRect.width;
        
        // Calculate position relative to the track
        const relativeX = clientX - trackRect.left;
        const clampedX = Math.max(0, Math.min(trackWidth, relativeX));
        
        // Update thumb position
        this.sliderThumb.style.left = `${clampedX}px`;
        
        // Calculate which bubble should be active
        const progress = clampedX / trackWidth;
        const newIndex = Math.round(progress * (this.bubbles.length - 1));
        
        if (newIndex !== this.currentIndex && newIndex >= 0 && newIndex < this.bubbles.length) {
          this.setActiveBubble(newIndex);
        }
      }

      handleSliderRelease() {
        this.isDragging = false;
        document.removeEventListener('mousemove', this.handleSliderDrag.bind(this));
        document.removeEventListener('mouseup', this.handleSliderRelease.bind(this));
        document.removeEventListener('touchmove', this.handleSliderDrag.bind(this));
        document.removeEventListener('touchend', this.handleSliderRelease.bind(this));
      }

      showBubbleDetail(bubbleData) {
        document.getElementById('modalTitle').textContent = bubbleData.title;
        document.getElementById('modalDescription').textContent = bubbleData.description;
        
        // Format date properly
        const date = new Date(bubbleData.rawDate);
        const formattedDate = date.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        document.getElementById('modalDate').textContent = formattedDate;
        
        const modalPhoto = document.getElementById('modalPhoto');
        if (bubbleData.hasPhoto && bubbleData.photo) {
          modalPhoto.src = bubbleData.photo;
          modalPhoto.style.display = 'block';
        } else {
          modalPhoto.style.display = 'none';
        }
        
        this.modal.classList.add('show');
      }

      hideBubbleDetail() {
        this.modal.classList.remove('show');
      }

      toggleView() {
        this.isGridView = !this.isGridView;
        
        if (this.isGridView) {
          // Show grid view
          this.timelineContainer.style.display = 'none';
          this.gridContainer.classList.add('show');
          document.getElementById('timelineSlider').style.display = 'none';
        } else {
          // Show timeline view
          this.timelineContainer.style.display = 'flex';
          this.gridContainer.classList.remove('show');
          document.getElementById('timelineSlider').style.display = 'flex';
        }
      }
    }

    // Initialize Mymory Timeline when page loads
    document.addEventListener('DOMContentLoaded', () => {
      new MymoryTimeline();
    });
  </script>
</body>
</html>
